
-- Global variables
local angleTick = 0

loadstring([[
local function LPH_NO_VIRTUALIZE(f) return f end;
]])();

-- Safely get Players service
local players = game:GetService("Players")
local player

local tweenService = game:GetService("TweenService")
local statsService = game:GetService("Stats")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local httpService = game:GetService("HttpService")
local starterGui = game:GetService("StarterGui")

-- Get player reference safely
local success, result = pcall(function()
    return players.LocalPlayer
end)
if success then
    player = result
else
    -- Fallback if we can't get the player
    for _, p in pairs(players:GetPlayers()) do
        player = p
        break
    end
end

local mouse
pcall(function()
    mouse = player and player:GetMouse()
end)

local camera = workspace.CurrentCamera
local values = nil

pcall(function()
    values = replicatedStorage:FindFirstChild("Values")
end)

local IS_PRACTICE = game.PlaceId == 8206123457
local IS_SOLARA = typeof(getexecutorname) == "function" and string.match(getexecutorname(), "Solara") or false
local AC_BYPASS = IS_PRACTICE

local moveToUsing = {}

-- Clean up old moveToUsing times
task.spawn(function()
    while true do
        task.wait(5)
        local currentTime = os.clock()
        for i = #moveToUsing, 1, -1 do
            if currentTime - moveToUsing[i] > 2 then
                table.remove(moveToUsing, i)
            end
        end
    end
end)

-- Track last moveTo time
task.spawn(function()
    local oldMoveTo = player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.MoveTo

    if oldMoveTo then
        player.Character.Humanoid.MoveTo = function(self, position, ...)
            table.insert(moveToUsing, os.clock())
            return oldMoveTo(self, position, ...)
        end
    end

    player.CharacterAdded:Connect(function(character)
        local humanoid = character:WaitForChild("Humanoid")
        local oldMoveTo = humanoid.MoveTo

        humanoid.MoveTo = function(self, position, ...)
            table.insert(moveToUsing, os.clock())
            return oldMoveTo(self, position, ...)
        end
    end)
end)

if not values or IS_PRACTICE then
    if replicatedStorage:FindFirstChild("Values") then
        replicatedStorage:FindFirstChild("Values"):Destroy()
    end
    values = Instance.new("Folder")
    local status = Instance.new("StringValue")
    status.Name = "Status"
    status.Value = "InPlay"
    status.Parent = values
    values.Parent = replicatedStorage
    values.Name = "Values"
end

if not LPH_OBFUSCATED then
    getfenv().LPH_NO_VIRTUALIZE = function(f) return f end
end

local Handshake = replicatedStorage.Remotes.CharacterSoundEvent
local Hooks = {}
local HandshakeInts = {}

LPH_NO_VIRTUALIZE(function()
    for i, v in getgc() do
        if typeof(v) == "function" and islclosure(v) then
            if (#getprotos(v) == 1) and table.find(getconstants(getproto(v, 1)), 4000001) then
                hookfunction(v, function() end)
            end
        end
    end
end)()

Hooks.__namecall = hookmetamethod(game, "__namecall", LPH_NO_VIRTUALIZE(function(self, ...)
    local Method = getnamecallmethod()
    local Args = {...}

    if not checkcaller() and (self == Handshake) and (Method == "fireServer") and (string.find(Args[1], "AC")) then
        if (#HandshakeInts == 0) then
            HandshakeInts = {table.unpack(Args[2], 2, 18)}
        else
            for i, v in HandshakeInts do
                Args[2][i + 1] = v
            end
        end
    end

    return Hooks.__namecall(self, ...)
end))

task.wait(1)

if not isfolder("Sense Hub") then
    makefolder("Sense Hub")
end

local SenseUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/RealVeylo/skidmf/refs/heads/main/skid?token=GHSAT0AAAAAADEZ6QRPWRR5WSF6XSOX4RMS2BZUMUA"))()

local function safeIndex(t, index)
    if type(t) ~= "table" and type(t) ~= "userdata" then
        return nil
    end

    local success, result = pcall(function()
        return t[index]
    end)

    if success then
        return result
    else
        return nil
    end
end


local Window = SenseUI:CreateWindow({
    Title = "Sense Hub",
    SubTitle = "by Veylo",
    Size = UDim2.fromOffset(600, 350),
    MobileIconId = "129937299302497"
})

local Tabs = {
    Catching = Window:AddTab({ Title = "Catching", Icon = "radio", ScrollingEnabled = true }),
    Physics = Window:AddTab({ Title = "Physics", Icon = "rocket", ScrollingEnabled = true }),
    Auto = Window:AddTab({ Title = "Auto", Icon = "bot", ScrollingEnabled = true }),
    Player = Window:AddTab({ Title = "Player", Icon = "user", ScrollingEnabled = true }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings", ScrollingEnabled = true })
}

local Options = SenseUI.Options

local QuickTPToggle = Tabs.Physics:AddToggle("QuickTP", {
    Title = "Quick TP",
    Default = false,
    Description = "Teleport quickly in the direction you're moving"
})

local QuickTPSpeed = Tabs.Physics:AddSlider("QuickTPSpeed", {
    Title = "Speed",
    Description = "QuickTP speed multiplier",
    Default = 3,
    Min = 1,
    Max = 5,
    Rounding = 1
})

local QuickTPBind = Tabs.Physics:AddKeybind("QuickTPBind", {
    Title = "Keybind",
    Default = "F",
    Mode = "Toggle",
    Description = "Key to activate Quick TP"
})

local ClickTackleAimbotToggle = Tabs.Physics:AddToggle("ClickTackleAimbot", {
    Title = "Click Tackle Aimbot",
    Default = false,
    Description = "Teleport to the ball carrier when clicking"
})

local ClickTackleAimbotDistance = Tabs.Physics:AddSlider("ClickTackleAimbotDistance", {
    Title = "Distance",
    Description = "Maximum teleport distance",
    Default = 7,
    Min = 0,
    Max = 15,
    Rounding = 1
})

local AntiJamToggle = Tabs.Physics:AddToggle("AntiJam", {
    Title = "Anti Jam",
    Default = false,
    Description = "Prevents you from getting jammed"
})

local AntiBlockToggle = Tabs.Physics:AddToggle("AntiBlock", {
    Title = "Anti Block",
    Default = false,
    Description = "Prevents players from blocking you"
})

local VisualizeBallPathToggle = Tabs.Physics:AddToggle("VisualizeBallPath", {
    Title = "Visualize Ball Path",
    Default = false,
    Description = "Shows the path of the ball"
})

local NoJumpCooldownToggle = Tabs.Physics:AddToggle("NoJumpCooldown", {
    Title = "No Jump Cooldown",
    Default = false,
    Description = "Removes the cooldown between jumps"
})

local NoFreezeToggle = Tabs.Physics:AddToggle("NoFreeze", {
    Title = "No Freeze",
    Default = false,
    Description = "Prevents movement freezing"
})

local OptimalJumpToggle = Tabs.Physics:AddToggle("OptimalJump", {
    Title = "Optimal Jump",
    Default = false,
    Description = "Shows the best position to jump for catches"
})

local OptimalJumpType = Tabs.Physics:AddDropdown("OptimalJumpType", {
    Title = "Type",
    Values = {"Jump", "Dive"},
    Default = "Jump",
    Description = "Jump or dive indicator"
})

local NoBallTrailToggle = Tabs.Physics:AddToggle("NoBallTrail", {
    Title = "No Ball Trail",
    Default = false,
    Description = "Removes the trail behind the ball"
})

local BigHeadToggle = Tabs.Physics:AddToggle("BigHead", {
    Title = "Big Head",
    Default = false,
    Description = "Increases the size of player heads"
})

local BigHeadSize = Tabs.Physics:AddSlider("BigHeadSize", {
    Title = "Size",
    Description = "Head size multiplier",
    Default = 3,
    Min = 1,
    Max = 5,
    Rounding = 1
})

local DivePowerToggle = Tabs.Player:AddToggle("DivePower", {
    Title = "Dive Power",
    Default = false,
    Description = "Enhances diving distance"
})

local DivePowerDistance = Tabs.Player:AddSlider("DivePowerDistance", {
    Title = "Dive Distance",
    Description = "Additional dive force multiplier",
    Default = 3,
    Min = 0,
    Max = 10,
    Rounding = 1
})

local AntiOOBToggle = Tabs.Physics:AddToggle("AntiOOB", {
    Title = "Anti Out Of Bounds",
    Default = false,
    Description = "Prevents going out of bounds by toggling boundaries"
})
local SpeedToggle = Tabs.Player:AddToggle("Speed", {
    Title = "Speed",
    Default = false,
    Description = "Increases your movement speed"
})

local SpeedValue = Tabs.Player:AddSlider("SpeedValue", {
    Title = "Speed",
    Description = "Speed multiplier",
    Default = 22,
    Min = 20,
    Max = 23,
    Rounding = 1,
    Callback = function(Value)
        if Options.Speed and Options.Speed.Value then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = Value
            end
        end
    end
})

local JumpPowerToggle = Tabs.Player:AddToggle("JumpPower", {
    Title = "Jump Power",
    Default = false,
    Description = "Increases your jump height"
})

local JumpPowerValue = Tabs.Player:AddSlider("JumpPowerValue", {
    Title = "Power",
    Description = "Jump power multiplier",
    Default = 60,
    Min = 50,
    Max = 70,
    Rounding = 1,
    Callback = function(Value)
        if Options.JumpPower and Options.JumpPower.Value then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid then
                if AC_BYPASS then
                    humanoid.JumpPower = Value
                end
            end
        end
    end
})

local AngleAssistToggle = Tabs.Player:AddToggle("AngleAssist", {
    Title = "Angle Enhancer",
    Default = false,
    Description = "Enhances your angles"
})

local AngleAssistJP = Tabs.Player:AddSlider("AngleAssistJP", {
    Title = "JP",
    Description = "Jump power for angle assist",
    Default = 60,
    Min = 50,
    Max = 70,
    Rounding = 1,
    Callback = function(Value)
        if Options.AngleAssist and Options.AngleAssist.Value then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid and AC_BYPASS then
                humanoid.JumpPower = Value
            end
        end
    end
})

local AutoCapToggle = Tabs.Auto:AddToggle("AutoCap", {
    Title = "Auto Cap",
    Default = false,
    Description = "Makes you auto win the race for captain"
})


local AutoResetToggle = Tabs.Auto:AddToggle("AutoReset", {
    Title = "Auto Reset After Catch",
    Default = false,
    Description = "Automatically reset after catching"
})

local AutoResetDelay = Tabs.Auto:AddSlider("AutoResetDelay", {
    Title = "Reset Delay",
    Description = "Delay before resetting (seconds)",
    Default = 1,
    Min = 0,
    Max = 5,
    Rounding = 1
})

local AutoBoostToggle = Tabs.Auto:AddToggle("AutoBoost", {
    Title = "Auto Boost",
    Default = false,
    Description = "Automatically boosts you when you jump."
})


local boundaries = {}

if not IS_PRACTICE then
    for index, part in pairs(workspace.Models.Boundaries:GetChildren()) do
        boundaries[#boundaries + 1] = part
    end
end

-- Anti OOB implementation
task.spawn(function()
    while true do
        task.wait()

        if Options.AntiOOB and Options.AntiOOB.Value then
            for _, boundary in pairs(boundaries) do
                if boundary and boundary.Parent then
                    boundary.Parent = nil
                end
            end
        else
            for _, boundary in pairs(boundaries) do
                if boundary and not boundary.Parent then
                    boundary.Parent = workspace.Models.Boundaries
                end
            end
        end
    end
end)

if firetouchinterest and not IS_SOLARA then
    local TackleExtenderToggle = Tabs.Physics:AddToggle("TackleExtender", {
        Title = "Tackle Extender",
        Default = false,
        Description = "Extends your tackle reach"
    })

    local TackleExtenderRadius = Tabs.Physics:AddSlider("TackleExtenderRadius", {
        Title = "Radius",
        Description = "Tackle extension distance",
        Default = 5,
        Min = 0,
        Max = 10,
        Rounding = 1
    })

    task.spawn(function()
        while true do
            task.wait()

            local possessor = findPossessor()
            local character = player.Character
            local hrp = character and character:FindFirstChild("HumanoidRootPart")

            if not hrp then continue end
            if not possessor then continue end
            if not Options.TackleExtender.Value then continue end

            local distance = (hrp.Position - possessor.HumanoidRootPart.Position).Magnitude

            if distance > Options.TackleExtenderRadius.Value then continue end

            for index, part in pairs(possessor:GetChildren()) do
                if not part:IsA("BasePart") then continue end
                if not character:FindFirstChild(part.Name) then continue end
                firetouchinterest(character:FindFirstChild(part.Name), part, 0)
                firetouchinterest(character:FindFirstChild(part.Name), part, 1)
            end
        end
    end)
end

if AC_BYPASS then
    local BlockExtenderToggle = Tabs.Physics:AddToggle("BlockExtender", {
        Title = "Block Extender",
        Default = false,
        Description = "Extends your blocking range"
    })

    local BlockExtenderRange = Tabs.Physics:AddSlider("BlockExtenderRange", {
        Title = "Range",
        Description = "Block extension distance",
        Default = 10,
        Min = 1,
        Max = 20,
        Rounding = 1
    })

    local BlockExtenderTransparency = Tabs.Physics:AddSlider("BlockExtenderTransparency", {
        Title = "Transparency",
        Description = "Visual transparency of block zone",
        Default = 1,
        Min = 0,
        Max = 1,
        Rounding = 2 -- Changed from 1 to 2 for finer control (0.00-1.00)
    })

    -- REMOVED AntiPancakeBlockToggle and AntiPancakeBlockChance

    local flying = false
    -- REMOVED FlyToggle and FlySpeedSlider

    task.spawn(function()
        while true do
            task.wait()

            local character = player.Character
            local blockPart = character and character:FindFirstChild("BlockPart")

            if not blockPart then continue end

            blockPart.Size = Options.BlockExtender.Value and Vector3.new(Options.BlockExtenderRange.Value, Options.BlockExtenderRange.Value, Options.BlockExtenderRange.Value) or Vector3.new(0.75, 5, 1.5)
            blockPart.Transparency = Options.BlockExtender.Value and Options.BlockExtenderTransparency.Value or 1
        end
    end)
end

local function getPing()
    return statsService.PerformanceStats.Ping:GetValue()
end

local function getServerPing()
    return statsService.Network.ServerStatsItem['Data Ping']:GetValue()
end

local function findClosestBall()
    local lowestDistance = math.huge
    local nearestBall = nil

    local character = player.Character
    if not character then return nil end

    for index, ball in pairs(workspace:GetChildren()) do
        if ball.Name ~= "Football" then continue end
        if not ball:IsA("BasePart") then continue end
        if not character:FindFirstChild("HumanoidRootPart") then continue end
        local distance = (ball.Position - character.HumanoidRootPart.Position).Magnitude

        if distance < lowestDistance then
            nearestBall = ball
            lowestDistance = distance
        end
    end

    return nearestBall
end

local function getNearestPartToPartFromParts(part, parts)
    local lowestDistance = math.huge
    local nearestPart = nil

    for index, p in pairs(parts) do
        local distance = (part.Position - p.Position).Magnitude

        if distance < lowestDistance then
            nearestPart = p
            lowestDistance = distance
        end
    end

    return nearestPart
end

-- Added from fluentuifr.lua
local part = Instance.new("Part")
part.Transparency = 0.5
part.Anchored = true
part.CanCollide = false
part.CastShadow = false
part.Color = Color3.fromRGB(85, 170, 255)
part.Shape = Enum.PartType.Ball
part.Material = Enum.Material.ForceField
part.Parent = workspace

-- Added from fluentuifr.lua
function beamProjectile(g, v0, x0, t1)
    local c = 0.5*0.5*0.5;
    local p3 = 0.5*g*t1*t1 + v0*t1 + x0;
    local p2 = p3 - (g*t1*t1 + v0*t1)/3;
    local p1 = (c*g*t1*t1 + 0.5*v0*t1 + x0 - c*(x0+p3))/(3*c) - p2;

    local curve0 = (p1 - x0).magnitude;
    local curve1 = (p2 - p3).magnitude;

    local b = (x0 - p3).unit;
    local r1 = (p1 - x0).unit;
    local u1 = r1:Cross(b).unit;
    local r2 = (p2 - p3).unit;
    local u2 = r2:Cross(b).unit;
    b = u1:Cross(r1).unit;

    local cf1 = CFrame.new(
        x0.x, x0.y, x0.z,
        r1.x, u1.x, b.x,
        r1.y, u1.y, b.y,
        r1.z, u1.z, b.z
    )

    local cf2 = CFrame.new(
        p3.x, p3.y, p3.z,
        r2.x, u2.x, b.x,
        r2.y, u2.y, b.y,
        r2.z, u2.z, b.z
    )

    return curve0, -curve1, cf1, cf2;
end

task.spawn(function()
    while true do
        task.wait(0.1)
        ping = ( getPing() + getServerPing() ) / 1000
    end
end)

task.spawn(function()
    runService.RenderStepped:Connect(function()
        fps += 1
        task.delay(1, function()
            fps -= 1
        end)
    end)
end)

local function findPossessor()
    if not players then return nil end

    for _, plr in pairs(players:GetPlayers()) do
        if not plr or not plr.Character then continue end
        local character = plr.Character
        if not character:FindFirstChildWhichIsA("Tool") then continue end
        return character
    end
    return nil
end

-- Added from fluentuifr.lua
local MagnetsToggle = Tabs.Catching:AddToggle("Magnets", {
    Title = "Magnets",
    Default = false,
    Description = "Helps you catch the ball"
})

local MagnetsType = Tabs.Catching:AddDropdown("MagnetsType", {
    Title = "Type",
    Values = {"Blatant", "Legit", "League"},
    Default = "League",
    Description = "How the magnets behavior is"
})

local MagnetsCustomRadius = Tabs.Catching:AddSlider("MagnetsCustomRadius", {
    Title = "Radius",
    Description = "Radius for the Magnets",
    Default = 35,
    Min = 0,
    Max = 70,
    Rounding = 1
})

local ShowMagHitbox = Tabs.Catching:AddToggle("ShowMagHitbox", {
    Title = "Visualise Hitbox",
    Default = false,
    Description = "Displays the mag hitbox"
})

-- QB Aimbot Logic (Main hook and related variables/functions - Commented out as feature is COMING SOON)
-- ... (omitted for brevity, unchanged) ...

-- Added from fluentuifr.lua
local fakeBalls = {}
local pullVectoredBalls = {}
local velocity = {}
local isCatching = false

-- Clear tables periodically to prevent memory leaks (from fluentuifr.lua)
task.spawn(function()
    while true do
        task.wait(30)
        for ball, _ in pairs(pullVectoredBalls) do
            if not ball or not ball.Parent then
                pullVectoredBalls[ball] = nil
            end
        end

        for ball, _ in pairs(fakeBalls) do
            if not ball or not ball.Parent then
                if fakeBalls[ball] and fakeBalls[ball].Parent then
                    fakeBalls[ball]:Destroy()
                end
                fakeBalls[ball] = nil
            end
        end

        for ball, _ in pairs(velocity) do
            if not ball or not ball.Parent then
                velocity[ball] = nil
            end
        end
    end
end)

-- Dive Power Hook from custom.lua
local divePowerOldNamecall
divePowerOldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
    local method, args = getnamecallmethod(), {...}
    if args[2] == "dive" and Options.DivePower and Options.DivePower.Value then
        local character = player.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            local currentVelocity = humanoidRootPart.Velocity
            local diveForce = Options.DivePowerDistance and Options.DivePowerDistance.Value or 3
            local enhancedVelocity = currentVelocity + (currentVelocity.Unit * diveForce)
            humanoidRootPart.Velocity = enhancedVelocity
        end
    end
    return divePowerOldNamecall(self, ...)
end)

local PullVectorToggle = Tabs.Catching:AddToggle("PullVector", {
    Title = "Pull Vector",
    Default = false,
    Description = "Pulls you towards the ball"
})

local PullVectorDistance = Tabs.Catching:AddSlider("PullVectorDistance", {
    Title = "Distance",
    Description = "Maximum distance to activate pull",
    Default = 50,
    Min = 0,
    Max = 100,
    Rounding = 1
})

local PullVectorType = Tabs.Catching:AddDropdown("PullVectorType", {
    Title = "Type",
    Values = {"Glide", "Teleport"},
    Default = "Glide"
})

local PullVectorPower = Tabs.Catching:AddSlider("PullVectorPower", {
    Title = "Power",
    Description = "Strength of the pull effect",
    Default = 3,
    Min = 1,
    Max = 5,
    Rounding = 1
})

-- Freeze Tech (Post-Catch) from custom.lua
local FreezeTechToggle = Tabs.Catching:AddToggle("FreezeTech", {
    Title = "Freeze Tech",
    Default = false,
    Description = "Freeze after catching the ball"
})

local FreezeTechDuration = Tabs.Catching:AddSlider("FreezeTechDuration", {
    Title = "Freeze Duration",
    Description = "How long to freeze after catch (seconds)",
    Default = 0.5,
    Min = 0,
    Max = 3,
    Rounding = 2 -- This was already correct
})

-- Define firetouchinterest with proper fallback
firetouchinterest = firetouchinterest or function() end

-- Customize firetouchinterest for Solara (adapted from fluentuifr.lua, SenseHub already has IS_SOLARA check)
if IS_SOLARA then
    local originalFiretouchinterest = firetouchinterest
    firetouchinterest = function(part2, part1, state)
        if AC_BYPASS then
            return originalFiretouchinterest(part2, part1, state)
        else
            state = state == 1
            local fakeBall = fakeBalls[part1]
            if not fakeBall then return end

            local direction = (part2.Position - fakeBall.Position).Unit
            local distance = (part2.Position - fakeBall.Position).Magnitude

            for i = 1,5,1 do
                local percentage = i/5 + Random.new():NextNumber(0.01, 0.02)
                part1.CFrame = fakeBall.CFrame + (direction * distance * percentage)
            end
        end
    end
end

local function onCharacterCatching(character)
    if not character then return end

    local arm
    local success = pcall(function()
        arm = character:WaitForChild('Left Arm', 5)
    end)

    if not success or not arm then return end

    arm.ChildAdded:Connect(function(child)
        if not child:IsA("Weld") then return end
        isCatching = true
        task.wait(1.7)
        isCatching = false
    end)

    -- Freeze Tech implementation
    local hrp = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart")

    character.ChildAdded:Connect(function(child)
        if child.Name == "Football" and child:IsA("Tool") then
            -- Freeze Tech
            if Options.FreezeTech and Options.FreezeTech.Value then
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local hrp = character:FindFirstChild("HumanoidRootPart")

                if humanoid and hrp and humanoid.FloorMaterial == Enum.Material.Air then
                    if not IS_PRACTICE then
                        if values and values.Status.Value ~= "InPlay" then return end
                    end

                    local originalWalkSpeed = humanoid.WalkSpeed
                    local originalJumpPower = humanoid.JumpPower -- Or JumpHeight, assuming JumpPower is used
                    -- Store the CFrame *before* anchoring or making changes.
                    -- No need to re-apply CFrame if Anchored = true is respected by the game engine for stopping movement.
                    -- local frozenCFrame = hrp.CFrame

                    humanoid.WalkSpeed = 0
                    humanoid.JumpPower = 0
                    -- humanoid.AutoRotate = false -- Consider if you want to disable server-side character auto-turning
                    hrp.Anchored = true

                    local freezeDuration = Options.FreezeTechDuration and Options.FreezeTechDuration.Value or 0.5
                    if freezeDuration <= 0 then freezeDuration = 0.01 end -- Ensure a minimum delay if set to 0, to allow un-anchor to process

                    task.delay(freezeDuration, function()
                        -- Check if character and humanoid still exist and are part of the workspace
                        if character and character.Parent and humanoid and humanoid.Parent and hrp and hrp.Parent then
                            hrp.Anchored = false
                            humanoid.WalkSpeed = originalWalkSpeed
                            humanoid.JumpPower = originalJumpPower
                            -- humanoid.AutoRotate = true -- Restore if it was changed
                        end
                    end)
                end
            end

            -- Auto Reset After Catch
            if Options.AutoReset and Options.AutoReset.Value then
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid then
                    task.wait(Options.AutoResetDelay and Options.AutoResetDelay.Value or 1)
                    humanoid.Health = 0
                end
            end
        end
    end)
end

workspace.ChildAdded:Connect(function(ball)
    if ball.Name ~= "Football" then return end
    if not ball:IsA("BasePart") then return end
    task.wait()

    -- Ball velocity tracking and Solara fake ball system (from fluentuifr.lua)
    local lastPosition = ball.Position
    local lastCheck = os.clock()
    local initalVelocity = Vector3.new(0, 0, 0)
    pcall(function()
        if ball and typeof(ball) == "Instance" and ball:IsA("BasePart") then
            initalVelocity = ball.Velocity
        end
    end)

    if (IS_SOLARA) and ball:FindFirstChildWhichIsA("Trail") and not ball.Anchored and camera.CameraSubject ~= ball then
        local fakeBall = ball:Clone()
        fakeBall.Name = "FFootball"
        fakeBall.Parent = workspace
        fakeBall.Anchored = true
        fakeBall.CanCollide = false
        if fakeBall:FindFirstChildWhichIsA('PointLight') then
            fakeBall:FindFirstChildWhichIsA('PointLight'):Destroy()
        end
        ball.Transparency = 1
        local spiralDegrees = 0
        fakeBalls[ball] = fakeBall
        task.spawn(function()
            while ball.Parent == workspace do
                local dt = runService.Heartbeat:Wait()
                spiralDegrees += 1500 * dt
                initalVelocity += Vector3.new(0, -28 * dt, 0)
                fakeBall.Position += initalVelocity * dt
                fakeBall.CFrame = CFrame.lookAt(fakeBall.Position, fakeBall.Position + initalVelocity) * CFrame.Angles(math.rad(90), math.rad(spiralDegrees), 0)

                if ball:FindFirstChildWhichIsA("Trail") then
                    ball:FindFirstChildWhichIsA("Trail").Enabled = false
                end
            end
            if fakeBall and fakeBall.Parent then
                fakeBall:Destroy()
            end
            fakeBalls[ball] = nil
        end)
    end

    task.spawn(function()
        while ball.Parent do
            task.wait(0.1)
            local t = (os.clock() - lastCheck)
            pcall(function()
                if ball and typeof(ball) == "Instance" and ball:IsA("BasePart") then
                    velocity[ball] = (ball.Position - lastPosition) / t
                end
            end)
            lastCheck = os.clock()
            pcall(function()
                if ball and typeof(ball) == "Instance" and ball:IsA("BasePart") then
                    lastPosition = ball.Position
                end
            end)
        end
        velocity[ball] = nil
        fakeBalls[ball] = nil
    end)

    if Options.NoBallTrail.Value and ball:FindFirstChildWhichIsA("Trail") then
        ball:FindFirstChildWhichIsA("Trail").Enabled = false
    end

    task.spawn(function()
        if not Options.OptimalJump.Value then return end
        local initalVelocity = Vector3.new(0, 0, 0)
        pcall(function()
            if ball and typeof(ball) == "Instance" and ball:IsA("BasePart") then
                initalVelocity = ball.Velocity
            end
        end)
        local optimalPosition = Vector3.zero

        local currentPosition = ball.Position

        local t = 0

        while true do
            t += 0.05
            initalVelocity += Vector3.new(0, -28 * 0.05, 0)
            currentPosition += initalVelocity * 0.05
            local raycastParams = RaycastParams.new()
            raycastParams.FilterDescendantsInstances = {workspace:FindFirstChild("Models")}
            raycastParams.FilterType = Enum.RaycastFilterType.Include

            local ray = workspace:Raycast(currentPosition, Vector3.new(0, Options.OptimalJumpType.Value == "Jump" and -13 or -15, 0), raycastParams)
            local antiCrashRay = workspace:Raycast(currentPosition, Vector3.new(0, -500, 0), raycastParams)

            if ray and t > 0.75 then
                optimalPosition = ray.Position + Vector3.new(0, 2, 0)
                break
            end

            if not antiCrashRay then
                optimalPosition = currentPosition
                break
            end
        end

        local part = Instance.new("Part")
        part.Anchored = true
        part.Material = Enum.Material.Neon
        part.Size = Vector3.new(1.5, 1.5, 1.5)
        part.Position = optimalPosition
        part.CanCollide = false
        part.Color = Color3.fromRGB(85, 170, 255)
        part.Parent = workspace

        repeat task.wait() until ball.Parent ~= workspace

        part:Destroy()
    end)

    -- Ball Path Visualization from fluentuifr.lua
    task.spawn(function()
        if not Options.VisualizeBallPath.Value then return end
        local currentInitialVelocity = Vector3.new(0,0,0)
        pcall(function()
            if ball and ball:IsA("BasePart") then currentInitialVelocity = ball.Velocity end
        end)

        local a0, a1 = Instance.new("Attachment"), Instance.new("Attachment")
        a0.Parent = workspace.Terrain; a1.Parent = workspace.Terrain

        local beam = Instance.new("Beam", workspace.Terrain)
        beam.Attachment0 = a0
        beam.Attachment1 = a1
        beam.Segments = 500
        beam.Width0 = 0.5
        beam.Width1 = 0.5
        beam.Transparency = NumberSequence.new(0)
        beam.Color = ColorSequence.new(Color3.fromRGB(0, 255, 255))

        local g = Vector3.new(0, -28 ,0)
        local x0 = ball.Position
        local v0 = currentInitialVelocity

        local curve0, curve1, cf1, cf2 = beamProjectile(g, v0, x0, 5)

        beam.CurveSize0 = curve0
        beam.CurveSize1 = curve1
        a0.CFrame = a0.Parent.CFrame:inverse() * cf1
        a1.CFrame = a1.Parent.CFrame:inverse() * cf2

        repeat task.wait() until not ball or ball.Parent ~= workspace

        if beam then beam:Destroy() end
        if a0 then a0:Destroy() end
        if a1 then a1:Destroy() end
    end)
end)

local quickTPCooldown = os.clock()

-- Magnet Hitbox Logic from fluentuifr.lua
task.spawn(function()
    while true do
        task.wait(1/60)
        local ball = findClosestBall()
        local character = player.Character
        local showHitboxOption = safeIndex(Options.ShowMagHitbox, "Value")
        local magnetsEnabled = Options.Magnets and Options.Magnets.Value

        -- Conditions for hiding the part if basic requirements aren't met
        if not ball or not character or not magnetsEnabled then
            if part and part.Parent then
                part.Parent = nil
            end
            continue
        end

        local catchLeft = character:FindFirstChild("CatchLeft")
        local catchRight = character:FindFirstChild("CatchRight")

        if not catchLeft or not catchRight then
            if part and part.Parent then part.Parent = nil end
            continue
        end

        local catchPart = getNearestPartToPartFromParts(ball, {catchLeft, catchRight})

        if not catchPart then
            if part and part.Parent then part.Parent = nil end
            continue
        end

        -- Default to hiding the part if ShowMagHitbox is off, this will be overridden if it should be shown
        if part and not showHitboxOption then
            part.Parent = nil
        end

        if Options.MagnetsType.Value == "League" then
            if not velocity[ball] then -- Specific check for League as it uses velocity for prediction
                if part and part.Parent then part.Parent = nil end
                continue
            end

            local predictedPosition = (fakeBalls[ball] or ball).Position + (velocity[ball] * ping)
            local distance = (catchPart.Position - predictedPosition).Magnitude

            part.Position = ball.Position -- VISUAL HITBOX FOLLOWS ACTUAL BALL
            part.Size = Vector3.new(
                safeIndex(Options.MagnetsCustomRadius, "Value") or 35,
                safeIndex(Options.MagnetsCustomRadius, "Value") or 35,
                safeIndex(Options.MagnetsCustomRadius, "Value") or 35
            )

            if magnetsEnabled and showHitboxOption then
                part.Parent = workspace
            else
                if part then part.Parent = nil end
            end

            if part and part.Parent then -- Only set these if part is visible
                part.Color = Color3.fromRGB(85, 170, 255)
                part.Material = Enum.Material.ForceField
                part.Transparency = 0.6
            end

            if distance <= (safeIndex(Options.MagnetsCustomRadius, "Value") or 35) then
                firetouchinterest(catchPart, ball, 0)
                firetouchinterest(catchPart, ball, 1)
            end
        else -- Blatant or other types
            -- For Blatant/Other, velocity check for part visibility might not be needed if positioning doesn't rely on it.
            -- The 'ball' check is already at the top.

            local distance = (catchPart.Position - ball.Position).Magnitude
            local radius = (Options.MagnetsType.Value == "Blatant" and 50 or 6)

            part.Position = (fakeBalls[ball] or ball).Position -- Keeping fakeBall consideration for Solara for these types for now
            part.Size = Vector3.new(radius, radius, radius)

            if magnetsEnabled and showHitboxOption then
                part.Parent = workspace
            else
                if part then part.Parent = nil end
            end

            if part and part.Parent then -- Only set these if part is visible
                part.Color = Color3.fromRGB(85, 170, 255)
                part.Material = Enum.Material.ForceField
                part.Transparency = 0.6
            end

            if not isCatching and IS_SOLARA then
                -- No action, hitbox remains if visible
            else
                if distance < radius then
                    firetouchinterest(catchPart, ball, 0)
                    firetouchinterest(catchPart, ball, 1)
                end
            end
        end
    end
end)

task.spawn(function()
    while true do
        task.wait()
        local ball = findClosestBall() if not ball then continue end
        local character = player.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

        if not ball:FindFirstChildWhichIsA("Trail") then continue end
        if not character or not humanoidRootPart then continue end
        if not Options.PullVector.Value then continue end
        if ball.Anchored then continue end

        local distance = (humanoidRootPart.Position - ball.Position).Magnitude
        if distance > Options.PullVectorDistance.Value then continue end

        local direction = (ball.Position - humanoidRootPart.Position).Unit

        if Options.PullVectorType.Value == "Teleport" then
            local dist = 10 + ((Options.PullVectorPower.Value - 1) * 5)
            pcall(function()
                if humanoidRootPart and typeof(humanoidRootPart) == "Instance" then
                    humanoidRootPart.CFrame += direction * dist
                end
            end)
        else
            pcall(function()
                if humanoidRootPart and typeof(humanoidRootPart) == "Instance" and humanoidRootPart:IsA("BasePart") then
                    local newVelocity = direction * Options.PullVectorPower.Value * 25
                    humanoidRootPart:SetVelocity(newVelocity)
                end
            end)
        end
    end
end)

onCharacterCatching(player.Character)
player.CharacterAdded:Connect(onCharacterCatching)

local function onCharacterPhysics(char)
    local humanoid = char:WaitForChild("Humanoid")
    local hrp = char:WaitForChild("HumanoidRootPart") -- Added for AutoBoost
    local legTouchedPlayerRecently = false -- Variable to track leg touch
    local touchConnectionLeft, touchConnectionRight -- To store Touch connections for later disconnect

    -- Function to handle leg touch
    local function onLegTouch(hit)
        if not Options.AutoBoost or not Options.AutoBoost.Value then return end
        local localPlayerChar = player.Character
        if not hit or not hit.Parent or not localPlayerChar or hit:IsDescendantOf(localPlayerChar) then return end

        local hitModel = hit.Parent
        local hitPlayer = players:GetPlayerFromCharacter(hitModel)

        if hitPlayer and hitPlayer ~= player then
            -- Check if the hit part is a leg or arm of another player (more specific than just any part)
            if string.match(hit.Name, "Leg") or string.match(hit.Name, "Arm") or string.match(hit.Name, "Torso") or string.match(hit.Name, "Head") then
                legTouchedPlayerRecently = true
                task.delay(0.3, function() legTouchedPlayerRecently = false end) -- Reset after 0.3 seconds
            end
        end
    end

    local leftLeg = char:FindFirstChild("Left Leg")
    local rightLeg = char:FindFirstChild("Right Leg")

    if leftLeg then
        touchConnectionLeft = leftLeg.Touched:Connect(onLegTouch)
    end
    if rightLeg then
        touchConnectionRight = rightLeg.Touched:Connect(onLegTouch)
    end

    -- Proper cleanup for touch connections when character is removed or humanoid dies
    local function cleanupTouchConnections()
        if touchConnectionLeft then
            touchConnectionLeft:Disconnect()
            touchConnectionLeft = nil
        end
        if touchConnectionRight then
            touchConnectionRight:Disconnect()
            touchConnectionRight = nil
        end
    end

    humanoid.Died:Connect(cleanupTouchConnections)
    char.AncestryChanged:Connect(function(_, parent)
        if not parent then
            cleanupTouchConnections()
        end
    end)

    char.DescendantAdded:Connect(function(v)
        task.wait()
        -- if v.Name:match("FFmover") and Options.AntiBlock.Value then -- Keep AntiBlock general logic if separate
        --    v:Destroy()
        -- end
    end)

    -- Auto Boost implementation - changed to on jump
    humanoid.Jumping:Connect(function(isJumping)
        if not isJumping then return end -- Only act when jump starts

        if Options.AutoBoost and Options.AutoBoost.Value and hrp and legTouchedPlayerRecently then
            legTouchedPlayerRecently = false -- Consume the touch for this jump
            -- Ensure player is actually moving upwards from a jump or is in air
            if humanoid:GetState() == Enum.HumanoidStateType.Jumping or humanoid.FloorMaterial == Enum.Material.Air then
                local boostPower = Options.AutoBoostPower and Options.AutoBoostPower.Value or 3
                local baseBoostMagnitude = 2 -- MODIFIED: Reduced from 5 to 2 for less height
                local impulseMagnitude = baseBoostMagnitude * boostPower

                hrp:ApplyImpulse(Vector3.new(0, impulseMagnitude * hrp.AssemblyMass, 0))
            end
        end
    end)

    task.spawn(function()
        while true do
            task.wait()
            if Options.NoJumpCooldown.Value then
                humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
            end

            local torso = char:FindFirstChild("Torso")
            local head = char:FindFirstChild("Head")

            if not torso or not head then return end

            if humanoid:GetState() == Enum.HumanoidStateType.Running and values.Status.Value == "InPlay" then
                torso.CanCollide = not Options.AntiJam.Value
                head.CanCollide = not Options.AntiJam.Value
            else
                torso.CanCollide = true
                head.CanCollide = true
            end
        end
    end)
end

task.spawn(function()
    local function applyChanges(character)
        local head = character and character:FindFirstChild("Head")
        local mesh = head and head:FindFirstChildWhichIsA("SpecialMesh")

        if not mesh then return end

        mesh.MeshType = Options.BigHead.Value and Enum.MeshType.Sphere or Enum.MeshType.Head
        head.Size = Options.BigHead.Value and Vector3.new(Options.BigHeadSize.Value, 1, Options.BigHeadSize.Value) or Vector3.new(2, 1, 1)
    end

    while true do
        task.wait()

        for index, plr in pairs(players:GetPlayers()) do
            if plr == players.LocalPlayer then continue end
            applyChanges(plr.Character)
        end
    end
end)

userInputService.InputBegan:Connect(function(input, gp)
    if gp then return end

    if not Options.QuickTPBind or not Options.QuickTPBind.Value then return end

    if input.KeyCode ~= Options.QuickTPBind.Value then return end

    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    local humanoid = character and character:FindFirstChild("Humanoid")

    if not Options.QuickTP or not Options.QuickTP.Value then return end
    if not character or not humanoidRootPart or not humanoid then return end
    if (os.clock() - quickTPCooldown) < 0.1 then return end

    local speed = 2 + ((Options.QuickTPSpeed and Options.QuickTPSpeed.Value or 3) / 4)

    humanoidRootPart.CFrame += humanoid.MoveDirection * speed
    quickTPCooldown = os.clock()
end)

mouse.Button1Down:Connect(function()
    if not Options.ClickTackleAimbot or not Options.ClickTackleAimbot.Value then return end

    local possessor = findPossessor()
    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

    if not character or not humanoidRootPart then return end
    if not possessor or not possessor:FindFirstChild("HumanoidRootPart") then return end

    local distance = (possessor.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
    if not Options.ClickTackleAimbotDistance or distance > Options.ClickTackleAimbotDistance.Value then return end

    humanoidRootPart.CFrame = possessor.HumanoidRootPart.CFrame
end)

onCharacterPhysics(player.Character)
player.CharacterAdded:Connect(onCharacterPhysics)

local function onCharacterMovement(character)
    local humanoid = character:WaitForChild("Humanoid")
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    task.spawn(function()
        while AC_BYPASS and humanoid.Parent do
            task.wait(.1)
            humanoid.JumpPower = Options.JumpPower.Value and Options.JumpPowerValue.Value or 50
        end
    end)

    humanoid.Jumping:Connect(function()
        if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then return end
        if AC_BYPASS then return end
        task.wait(0.05)
        if Options.JumpPower.Value then
            pcall(function()
                if humanoidRootPart and typeof(humanoidRootPart) == "Instance" and humanoidRootPart:IsA("BasePart") then
                    local jumpBoost = Options.JumpPowerValue.Value - 50
                    humanoidRootPart:ApplyImpulse(Vector3.new(0, jumpBoost * humanoidRootPart.AssemblyMass, 0))
                end
            end)
        end
    end)
end

onCharacterMovement(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(onCharacterMovement)

local angleTick = os.clock() -- Moved angleTick initialization here, used by AngleAssist

task.spawn(function()
    -- Removed: angleTick = os.clock() -- It's initialized outside now
    local oldLookVector = Vector3.new(0, 0, 0)
    local shiftLockEnabled = false
    local lastEnabled = false

    local function hookCharacter(character)
        local humanoid = character:WaitForChild("Humanoid")
        local hrp = character:WaitForChild("HumanoidRootPart")

        humanoid.Jumping:Connect(function(isJumpingState) -- Parameter often indicates if actively jumping
            if not (humanoid:GetState() == Enum.HumanoidStateType.Jumping) then return end -- Ensure actually jumping
            if not (Options.AngleAssist and Options.AngleAssist.Value) then return end
            if AC_BYPASS then return end -- Keep AC_BYPASS check

            if (os.clock() - (angleTick or 0)) < 0.25 then -- Check against angleTick (threshold 0.25s)
                if hrp then -- hrp already defined in hookCharacter's scope
                    local jpValue = Options.AngleAssistJP and Options.AngleAssistJP.Value or 50
                    local impulse = (jpValue - 50) * hrp.AssemblyMass
                    if impulse > 0 then
                         hrp:ApplyImpulse(Vector3.new(0, impulse, 0))
                    end
                    -- Optional: Add hint like bleachack if desired
                    -- if Options.AngleAssistIndicator and Options.AngleAssistIndicator.Value then -- Assuming you add such an option
                    --     local h = Instance.new("Hint")
                    --     h.Text = "Angled!"
                    --     h.Parent = workspace
                    --     game:GetService("Debris"):AddItem(h, 1)
                    -- end
                end
            end
        end)
    end

    hookCharacter(player.Character or player.CharacterAdded:Wait())

    player.CharacterAdded:Connect(hookCharacter)

    userInputService:GetPropertyChangedSignal("MouseBehavior"):Connect(function()
        if userInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
            shiftLockEnabled = true
        else
            if shiftLockEnabled then -- If it *was* LockCenter and now it's not
                angleTick = os.clock() -- Update angleTick when shift-lock is disengaged
            end
            shiftLockEnabled = false
        end
    end)

    while true do
        task.wait()
        local character = player.Character; if not character then continue end
        local hrp = character:FindFirstChild("HumanoidRootPart"); if not hrp then continue end
        local humanoid = character:FindFirstChild("Humanoid"); if not humanoid then continue end

        -- The old logic for AC_BYPASS and JumpPower adjustment based on angleTick can remain,
        -- as it's separate from the primary jump impulse.
        if AC_BYPASS then
            if (os.clock() - (angleTick or 0) < 0.2) and Options.AngleAssist and Options.AngleAssist.Value then -- Ensure Options.AngleAssist.Value is checked here too
                humanoid.JumpPower = (Options.JumpPower and Options.JumpPower.Value and Options.JumpPowerValue.Value or 50) + (Options.AngleAssistJP.Value - 50)
            elseif not (Options.AngleAssist and Options.AngleAssist.Value) then -- Use 'and Options.AngleAssist.Value' for clarity
                humanoid.JumpPower = (Options.JumpPower and Options.JumpPower.Value and Options.JumpPowerValue.Value or 50)
            end
        end

        oldLookVector = hrp.CFrame.LookVector
        lastEnabled = shiftLockEnabled
    end
end)

-- REMOVE THE OLD ANGLE ENHANCER LOGIC THAT MANIPULATES CAMERA AND MOUSEBEHAVIOR

runService:BindToRenderStep("walkSpeed", Enum.RenderPriority.Character.Value, function()
    local character = player.Character
    local humanoid = character and character:FindFirstChild("Humanoid")

    if not character or not humanoid then return end
    if humanoid:GetState() ~= Enum.HumanoidStateType.Running then return end
    if humanoid.WalkSpeed == 0 and not (Options.NoFreeze and Options.NoFreeze.Value) then return end
    if not character:FindFirstChild("HumanoidRootPart") then return end

    local moveDirection

    if moveToUsing and #moveToUsing > 0 and (os.clock() - (moveToUsing[#moveToUsing] or 0)) < 0.5 then
        pcall(function()
            if humanoid.WalkToPoint and typeof(humanoid.WalkToPoint) == "Vector3" and
               character and character:FindFirstChild("HumanoidRootPart") and
               typeof(character.HumanoidRootPart.Position) == "Vector3" then
                local direction = (humanoid.WalkToPoint - character.HumanoidRootPart.Position)
                if direction.Magnitude > 0 then
                    moveDirection = direction.Unit
                end
            end
        end)
    end

    if not moveDirection then
        moveDirection = humanoid.MoveDirection
    end

    local currentVel = Vector3.new(0, 0, 0)
    pcall(function()
        if character and character:FindFirstChild("HumanoidRootPart") and
           typeof(character.HumanoidRootPart) == "Instance" and
           character.HumanoidRootPart:IsA("BasePart") then
            currentVel = character.HumanoidRootPart:GetVelocity()
        end
    end)

    if (Options.Speed and Options.Speed.Value) or (Options.NoFreeze and Options.NoFreeze.Value) then
        local speedVal = 20

        if Options.Speed and Options.Speed.Value and Options.SpeedValue then
            if type(Options.SpeedValue.Value) == "number" and Options.SpeedValue.Value > 20 then
                speedVal = Options.SpeedValue.Value
            end
        end

        pcall(function()
            if character and character:FindFirstChild("HumanoidRootPart") and
               typeof(character.HumanoidRootPart) == "Instance" and
               character.HumanoidRootPart:IsA("BasePart") then
                local newVelocity = Vector3.new(
                    moveDirection.X * speedVal,
                    currentVel.Y,
                    moveDirection.Z * speedVal
                )
                character.HumanoidRootPart:SetVelocity(newVelocity)
            end
        end)
    end
end)

-- Auto Reset / Auto Cap / etc. (existing code)
local finishLine = not IS_PRACTICE and workspace.Models.LockerRoomA.FinishLine or Instance.new('Part')

task.spawn(function()
    while true do
        task.wait()
        -- Only use AutoCap toggle for logic
        if not safeIndex(Options.AutoCap, "Value") then continue end
        if IS_PRACTICE then continue end

        local character = player.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if not hrp then continue end

        if not finishLine or typeof(finishLine) ~= "Instance" then continue end

        local distance
        pcall(function()
            distance = (hrp.Position - finishLine.Position).Magnitude
        end)

        if not distance or distance > 10 then continue end

        local possessor = findPossessor()
        if not possessor then continue end

        local possessorIsLocalPlayer = possessor == character
        if possessorIsLocalPlayer then
            local event = game:GetService("ReplicatedStorage").Remotes.Touchdown
            if event then
                event:FireServer()
            end
        end
    end
end)

task.spawn(function()
    while true do
        task.wait(0.5)

        if safeIndex(Options.Speed, "Value") and safeIndex(Options.SpeedValue, "Value") then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid then
                if AC_BYPASS then
                    humanoid.WalkSpeed = Options.SpeedValue.Value
                end
            end
        end

        if safeIndex(Options.JumpPower, "Value") and safeIndex(Options.JumpPowerValue, "Value") then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid and AC_BYPASS then
                humanoid.JumpPower = Options.JumpPowerValue.Value
            end
        end

        if safeIndex(Options.AngleAssist, "Value") and safeIndex(Options.AngleAssistJP, "Value") then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid and AC_BYPASS then
                if os.clock() - (angleTick or 0) < 0.2 then
                    humanoid.JumpPower = Options.AngleAssistJP.Value
                end
            end
        end
    end
end)

InterfaceManager:SetFolder("Sense Hub")
SaveManager:SetFolder("Sense Hub/ff2")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Tabs.Settings:AddButton({
    Title = "Save Config",
    Description = "Save current configuration",
    Callback = function()
        Fluent:Notify({
            Title = "Config System",
            Content = "Enter a name for your config in the prompt",
            Duration = 3
        })

        local configName = nil
        local success, result = pcall(function()
            return Fluent:Prompt({
                Title = "Save Configuration",
                Content = "Enter a name for your configuration",
                TextBoxValue = "",
                Buttons = {
                    {
                        Title = "Save",
                        Callback = function(textBoxValue)
                            configName = textBoxValue
                            return true
                        end
                    },
                    {
                        Title = "Cancel",
                        Callback = function()
                            return false
                        end
                    }
                }
            })
        end)

        if success and result and configName and #configName > 0 then
            local exported = SaveManager:SaveConfiguration(configName)
            if exported then
                 
            end
        end
    end
})

Tabs.Settings:AddButton({
    Title = "Load Config",
    Description = "Load a saved configuration",
    Callback = function()
        SaveManager:LoadConfiguration()
    end
})

for _, option in pairs(Options) do
    if type(option) == "table" and option.SetValue then
        local success, err = pcall(function()
            if option.Value == nil then
                option:SetValue(option.Default)
            end
        end)
    end
end

Window:SelectTab(1)
